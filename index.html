<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Drawing App with Smoothing, Select, Erase, and Audio Upload</title>
  <style>
    body { font-family: sans-serif; margin: 0; }
    #toolbar {
      display: flex; 
      gap: 10px; 
      padding: 10px; 
      background: #eee; 
      align-items: center;
    }
    #canvas { border: 1px solid #ccc; display:block; margin: 0 auto; touch-action: none;}
    .selected { outline: 2px solid blue; }
    .hidden { display:none; }
  </style>
</head>
<body>
  <div id="toolbar">
    <button id="drawBtn">Draw</button>
    <button id="selectBtn">Select</button>
    <button id="eraseBtn">Erase</button>
    <input type="file" id="audioInput" accept="audio/*">
    <span id="audioFileName"></span>
    <audio id="audioPlayer" controls class="hidden"></audio>
  </div>
  <canvas id="canvas" width="800" height="500"></canvas>
  <script>
    // --- Drawing state ---
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    let mode = 'draw'; // draw, select, erase
    let drawing = false;
    let currentLine = [];
    let lines = [];
    let selectedLineIdx = null;
    let dragOffset = {x:0, y:0};
    let dragging = false;

    // --- UI buttons ---
    document.getElementById('drawBtn').onclick = () => { mode = 'draw'; selectedLineIdx = null; redraw(); }
    document.getElementById('selectBtn').onclick = () => { mode = 'select'; selectedLineIdx = null; redraw(); }
    document.getElementById('eraseBtn').onclick = () => { mode = 'erase'; selectedLineIdx = null; redraw(); }

    // --- Audio upload ---
    const audioInput = document.getElementById('audioInput');
    const audioPlayer = document.getElementById('audioPlayer');
    const audioFileName = document.getElementById('audioFileName');
    audioInput.addEventListener('change', (e) => {
      const file = e.target.files[0];
      if (file) {
        audioFileName.textContent = file.name;
        const url = URL.createObjectURL(file);
        audioPlayer.src = url;
        audioPlayer.classList.remove('hidden');
      }
    });

    // --- Smoothing: Chaikin's algorithm ---
    function chaikinSmooth(points, iterations = 2) {
      let newPoints = points.slice();
      for (let iter = 0; iter < iterations; iter++) {
        let smoothed = [];
        for (let i = 0; i < newPoints.length - 1; i++) {
          let p0 = newPoints[i];
          let p1 = newPoints[i + 1];
          let Q = {
            x: 0.75 * p0.x + 0.25 * p1.x,
            y: 0.75 * p0.y + 0.25 * p1.y
          };
          let R = {
            x: 0.25 * p0.x + 0.75 * p1.x,
            y: 0.25 * p0.y + 0.75 * p1.y
          };
          smoothed.push(Q, R);
        }
        newPoints = [newPoints[0], ...smoothed, newPoints[newPoints.length-1]];
      }
      return newPoints;
    }

    // --- Mouse/touch helpers ---
    function getPos(e) {
      if (e.touches) e = e.touches[0];
      const rect = canvas.getBoundingClientRect();
      return {
        x: (e.clientX - rect.left) * (canvas.width / rect.width),
        y: (e.clientY - rect.top) * (canvas.height / rect.height)
      };
    }

    // --- Drawing ---
    function redraw() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      lines.forEach((line, idx) => {
        ctx.save();
        ctx.strokeStyle = (idx === selectedLineIdx) ? "#2979ff" : "#222";
        ctx.lineWidth = (idx === selectedLineIdx) ? 4 : 2;
        ctx.beginPath();
        const pts = chaikinSmooth(line.points);
        pts.forEach((pt, i) => {
          if (i === 0) ctx.moveTo(pt.x, pt.y);
          else ctx.lineTo(pt.x, pt.y);
        });
        ctx.stroke();
        ctx.restore();
      });
      // If currently drawing, show preview
      if (drawing && mode==='draw' && currentLine.length > 1) {
        ctx.save();
        ctx.strokeStyle = "#888";
        ctx.lineWidth = 2;
        ctx.beginPath();
        let pts = chaikinSmooth(currentLine);
        pts.forEach((pt, i) => {
          if (i === 0) ctx.moveTo(pt.x, pt.y);
          else ctx.lineTo(pt.x, pt.y);
        });
        ctx.stroke();
        ctx.restore();
      }
    }

    function onPointerDown(e) {
      const pos = getPos(e);
      if (mode === 'draw') {
        drawing = true;
        currentLine = [pos];
      } else if (mode === 'select') {
        selectedLineIdx = getLineAt(pos);
        if (selectedLineIdx !== null) {
          dragging = true;
          const line = lines[selectedLineIdx];
          dragOffset = { x: pos.x - line.points[0].x, y: pos.y - line.points[0].y };
        }
      } else if (mode === 'erase') {
        const idx = getLineAt(pos);
        if (idx !== null) {
          lines.splice(idx, 1);
          redraw();
        }
      }
      redraw();
    }

    function onPointerMove(e) {
      if (drawing && mode==='draw') {
        currentLine.push(getPos(e));
        redraw();
      } else if (dragging && mode==='select' && selectedLineIdx !== null) {
        const pos = getPos(e);
        const line = lines[selectedLineIdx];
        // Move all points by mouse delta
        const deltaX = pos.x - line.points[0].x - dragOffset.x;
        const deltaY = pos.y - line.points[0].y - dragOffset.y;
        line.points = line.points.map(pt => ({ x: pt.x + deltaX, y: pt.y + deltaY }));
        redraw();
      }
    }

    function onPointerUp(e) {
      if (drawing && mode==='draw') {
        if (currentLine.length > 1) {
          lines.push({ points: currentLine });
        }
        currentLine = [];
        drawing = false;
        redraw();
      }
      dragging = false;
    }

    // --- Hit test for selecting/erasing lines ---
    function getLineAt(pos, threshold = 7) {
      for (let idx = lines.length - 1; idx >= 0; idx--) { // top-most first
        const pts = chaikinSmooth(lines[idx].points);
        for (let i = 0; i < pts.length - 1; i++) {
          if (ptLineDist(pos, pts[i], pts[i+1]) < threshold) {
            return idx;
          }
        }
      }
      return null;
    }
    // Distance from point to line segment
    function ptLineDist(pt, a, b) {
      const A = pt.x - a.x, B = pt.y - a.y, C = b.x - a.x, D = b.y - a.y;
      const dot = A * C + B * D;
      const len_sq = C * C + D * D;
      let param = (len_sq !== 0) ? dot / len_sq : -1;
      if (param < 0) param = 0;
      else if (param > 1) param = 1;
      const xx = a.x + param * C, yy = a.y + param * D;
      return Math.hypot(pt.x - xx, pt.y - yy);
    }

    // --- Event listeners ---
    canvas.addEventListener('pointerdown', onPointerDown);
    canvas.addEventListener('pointermove', onPointerMove);
    canvas.addEventListener('pointerup', onPointerUp);
    canvas.addEventListener('pointerleave', onPointerUp);

    // Touch support for mobile
    canvas.addEventListener('touchstart', e => { e.preventDefault(); onPointerDown(e); }, { passive: false });
    canvas.addEventListener('touchmove', e => { e.preventDefault(); onPointerMove(e); }, { passive: false });
    canvas.addEventListener('touchend', e => { e.preventDefault(); onPointerUp(e); }, { passive: false });

    redraw();
  </script>
</body>
</html>
