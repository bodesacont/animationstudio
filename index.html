<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>High-Quality Animation Tool</title>
  <meta name="viewport" content="width=device-width,initial-scale=1.0">
  <style>
    body { font-family: Arial, sans-serif; background: #222; color: #eee; margin: 0; padding: 0; }
    .toolbar, .frame-controls { background: #333; display: flex; gap: 1em; align-items: center; padding: 1em; flex-wrap: wrap; }
    #canvas-container { display: flex; justify-content: center; align-items: center; padding: 1em; }
    #draw-canvas { border: 2px solid #444; background: #fff; border-radius: 8px; cursor: crosshair; box-shadow: 0 2px 16px #0007; }
    .frames-panel { display: flex; gap: 0.5em; padding: 1em; overflow-x: auto; background: #222; border-top: 2px solid #333; }
    .frame-thumb { width: 64px; height: 48px; border: 2px solid #444; border-radius: 4px; cursor: pointer; background: #fff; object-fit: contain; box-shadow: 0 1px 4px #0004; transition: border .2s; }
    .frame-thumb.selected { border: 2px solid #1e90ff; }
    button, input, select { border-radius: 4px; border: 1px solid #444; background: #2a2a2a; color: #eee; padding: .3em .7em; font-size: 1em; }
    button:active { background: #444; }
    .fps-speed-container { display: flex; gap: 1em; align-items: center; }
    .tool-btn.selected { background: #1e90ff; color: #fff; }
    #audio-name { color: #1e90ff; font-size: 0.95em; margin-left: .5em; }
    @media (max-width: 600px) {
      .frames-panel { flex-wrap: wrap; overflow-x: visible; }
      #draw-canvas { width: 100vw !important; height: calc(100vw * 0.75) !important; max-width: 100vw; }
    }
  </style>
</head>
<body>
  <div class="toolbar">
    <button id="draw-tool" class="tool-btn selected">üñäÔ∏è Draw</button>
    <button id="select-tool" class="tool-btn">üî≤ Select/Move</button>
    <button id="smooth-tool" class="tool-btn">‚ú® Smooth</button>
    <label>Color: <input type="color" id="color-picker" value="#1e90ff"></label>
    <label>Brush: <input type="range" id="brush-size" min="1" max="40" value="4"></label>
    <span class="fps-speed-container">
      <label>FPS: <input type="number" id="fps" min="1" max="60" value="12" style="width:3em"></label>
      <label>Speed:
        <select id="speed">
          <option value="0.5">0.5x</option>
          <option value="1" selected>1x</option>
          <option value="1.5">1.5x</option>
          <option value="2">2x</option>
        </select>
      </label>
    </span>
    <button id="play-btn">‚ñ∂Ô∏è Play</button>
    <button id="stop-btn" disabled>‚èπÔ∏è Stop</button>
    <button id="clear-btn">üßπ Clear</button>
    <button id="export-btn">üíæ Export</button>
    <button id="import-btn">üì• Import</button>
    <input type="file" id="import-file" style="display:none">
    <label>
      <input type="file" id="audio-upload" accept="audio/*" style="display:none">
      <button id="audio-btn">üéµ Upload Audio</button>
    </label>
    <span id="audio-name"></span>
  </div>
  <div id="canvas-container">
    <canvas id="draw-canvas" width="640" height="480"></canvas>
  </div>
  <div class="frame-controls toolbar">
    <button id="add-frame-btn">‚ûï Add Frame</button>
    <button id="dup-frame-btn">üìã Duplicate</button>
    <button id="del-frame-btn">üóëÔ∏è Delete</button>
    <button id="prev-frame-btn">‚¨ÖÔ∏è Prev</button>
    <button id="next-frame-btn">Next ‚û°Ô∏è</button>
    <span>Frame: <span id="current-frame"></span> / <span id="total-frames"></span></span>
  </div>
  <div class="frames-panel" id="frames-panel"></div>
  <audio id="audio-player" controls style="display:none"></audio>
  <script>
    // Tool State
    let TOOL_DRAW = 'draw', TOOL_SELECT = 'select', TOOL_SMOOTH = 'smooth';
    let currentTool = TOOL_DRAW;
    // Drawing State
    let strokes = [[]]; // Array of array of strokes per frame
    let currentFrameIdx = 0;
    let selectedStrokeIdx = null;
    let brushColor = '#1e90ff';
    let brushSize = 4;
    let isDrawing = false;
    let isMoving = false;
    let moveOffset = {x:0, y:0};
    let lastPoint = null;
    let isPlaying = false, playTimer = null;
    // Audio
    let audioURL = null, audioName = '';
    const canvas = document.getElementById('draw-canvas');
    const ctx = canvas.getContext('2d');
    const fpsInput = document.getElementById('fps');
    const speedInput = document.getElementById('speed');
    const colorPicker = document.getElementById('color-picker');
    const brushSizeInput = document.getElementById('brush-size');
    const currentFrameElem = document.getElementById('current-frame');
    const totalFramesElem = document.getElementById('total-frames');
    const framesPanel = document.getElementById('frames-panel');
    const audioPlayer = document.getElementById('audio-player');
    const audioNameEl = document.getElementById('audio-name');

    // ------------ Smoothing Algorithms -------------
    // Catmull-Rom spline to smooth points
    function smoothStroke(points, factor=8) {
      if (points.length < 3) return points.slice();
      let smoothed = [];
      for (let i = 0; i < points.length - 1; i++) {
        smoothed.push(points[i]);
        let next = points[i + 1];
        let mid = {
          x: (points[i].x + next.x) / 2,
          y: (points[i].y + next.y) / 2
        };
        smoothed.push(mid);
      }
      // Optionally downsample
      return downsample(smoothed, factor);
    }
    // Downsample points to reduce micro-movements
    function downsample(points, factor) {
      if (points.length <= factor) return points.slice();
      let out = [];
      let step = Math.max(1, Math.floor(points.length / factor));
      for (let i = 0; i < points.length; i += step) {
        out.push(points[i]);
      }
      out.push(points[points.length-1]);
      return out;
    }
    // Quadratic curve for drawing
    function drawStroke(ctx, stroke, opts={color:brushColor, size:brushSize, selected:false}) {
      if (stroke.length < 2) return;
      ctx.save();
      ctx.strokeStyle = opts.color;
      ctx.lineWidth = opts.size;
      ctx.lineCap = 'round';
      ctx.beginPath();
      ctx.moveTo(stroke[0].x, stroke[0].y);
      for (let i=1; i<stroke.length-1; i++) {
        let mid = {
          x: (stroke[i].x + stroke[i+1].x)/2,
          y: (stroke[i].y + stroke[i+1].y)/2
        };
        ctx.quadraticCurveTo(stroke[i].x, stroke[i].y, mid.x, mid.y);
      }
      ctx.lineTo(stroke[stroke.length-1].x, stroke[stroke.length-1].y);
      ctx.stroke();
      if (opts.selected) {
        ctx.strokeStyle = '#ff0'; ctx.lineWidth = opts.size+2;
        ctx.setLineDash([5,5]);
        ctx.stroke();
        ctx.setLineDash([]);
      }
      ctx.restore();
    }
    // ----------- Frame Management -------------
    function blankStrokes() {
      return [];
    }
    function initFrames() {
      strokes = [blankStrokes()];
      currentFrameIdx = 0;
      selectedStrokeIdx = null;
      renderFrame();
      renderFramesPanel();
      updateFrameCounter();
    }
    function saveFrame() {
      // No-op, all data in strokes array
      renderFramesPanel();
    }
    function renderFrame() {
      ctx.clearRect(0,0,canvas.width,canvas.height);
      const frameStrokes = strokes[currentFrameIdx] || [];
      frameStrokes.forEach((stroke, idx) => drawStroke(ctx, stroke, {
        color: stroke.color || brushColor,
        size: stroke.size || brushSize,
        selected: idx === selectedStrokeIdx
      }));
    }
    function renderFramesPanel() {
      framesPanel.innerHTML = '';
      for(let i=0; i<strokes.length; i++) {
        const thumb = document.createElement('canvas');
        thumb.width = 64; thumb.height = 48;
        thumb.className = 'frame-thumb' + (i===currentFrameIdx ? ' selected':'');
        thumb.title = `Frame ${i+1}`;
        let tctx = thumb.getContext('2d');
        tctx.fillStyle = '#fff'; tctx.fillRect(0,0,thumb.width,thumb.height);
        (strokes[i]||[]).forEach(stroke=>drawStroke(tctx, scaleStroke(stroke, 64/canvas.width, 48/canvas.height), {
          color: stroke.color || brushColor,
          size: Math.max(1,(stroke.size||brushSize)*0.1)
        }));
        thumb.onclick = ()=>{ saveFrame(); currentFrameIdx=i; selectedStrokeIdx=null; renderFrame(); renderFramesPanel(); updateFrameCounter(); };
        framesPanel.appendChild(thumb);
      }
    }
    function updateFrameCounter() {
      currentFrameElem.textContent = currentFrameIdx+1;
      totalFramesElem.textContent = strokes.length;
    }
    // Scale stroke for thumbnail
    function scaleStroke(stroke, sx, sy) {
      return stroke.map(pt=>({x:pt.x*sx, y:pt.y*sy}));
    }
    // ----------- Drawing Logic -------------
    canvas.onmousedown = e => {
      if (isPlaying || currentTool === TOOL_SELECT || currentTool === TOOL_SMOOTH) return;
      isDrawing = true;
      lastPoint = getCanvasPos(e);
      let frameStrokes = strokes[currentFrameIdx];
      frameStrokes.push([{...lastPoint, color:brushColor, size:brushSize}]);
      selectedStrokeIdx = frameStrokes.length-1;
      renderFrame();
    };
    canvas.onmousemove = e => {
      if (isPlaying) return;
      if (isDrawing && currentTool === TOOL_DRAW) {
        let frameStrokes = strokes[currentFrameIdx];
        let stroke = frameStrokes[selectedStrokeIdx];
        let pt = getCanvasPos(e);
        stroke.push({...pt, color:brushColor, size:brushSize});
        // Smooth in real time, ignore micro-movements
        if (stroke.length > 2) {
          frameStrokes[selectedStrokeIdx] = smoothStroke(stroke, 16);
        }
        renderFrame();
      } else if (isMoving && currentTool === TOOL_SELECT && selectedStrokeIdx !== null) {
        let pt = getCanvasPos(e);
        let dx = pt.x - moveOffset.x, dy = pt.y - moveOffset.y;
        let stroke = strokes[currentFrameIdx][selectedStrokeIdx];
        for(let i=0;i<stroke.length;i++) {
          stroke[i].x += dx; stroke[i].y += dy;
        }
        moveOffset = pt;
        renderFrame();
      }
    };
    canvas.onmouseup = e => {
      if (isPlaying) return;
      if (isDrawing && currentTool === TOOL_DRAW) {
        isDrawing = false;
        saveFrame();
      }
      if (isMoving && currentTool === TOOL_SELECT) {
        isMoving = false;
      }
    };
    canvas.onmouseleave = ()=>{ isDrawing = false; isMoving = false; };
    // Touch events
    canvas.ontouchstart = e => {
      if (isPlaying || currentTool === TOOL_SELECT || currentTool === TOOL_SMOOTH) return;
      e.preventDefault();
      isDrawing = true;
      lastPoint = getCanvasTouchPos(e);
      let frameStrokes = strokes[currentFrameIdx];
      frameStrokes.push([{...lastPoint, color:brushColor, size:brushSize}]);
      selectedStrokeIdx = frameStrokes.length-1;
      renderFrame();
    };
    canvas.ontouchmove = e => {
      if (isPlaying) return;
      if (isDrawing && currentTool === TOOL_DRAW) {
        e.preventDefault();
        let frameStrokes = strokes[currentFrameIdx];
        let stroke = frameStrokes[selectedStrokeIdx];
        let pt = getCanvasTouchPos(e);
        stroke.push({...pt, color:brushColor, size:brushSize});
        if (stroke.length > 2) {
          frameStrokes[selectedStrokeIdx] = smoothStroke(stroke, 16);
        }
        renderFrame();
      } else if (isMoving && currentTool === TOOL_SELECT && selectedStrokeIdx !== null) {
        e.preventDefault();
        let pt = getCanvasTouchPos(e);
        let dx = pt.x - moveOffset.x, dy = pt.y - moveOffset.y;
        let stroke = strokes[currentFrameIdx][selectedStrokeIdx];
        for(let i=0;i<stroke.length;i++) {
          stroke[i].x += dx; stroke[i].y += dy;
        }
        moveOffset = pt;
        renderFrame();
      }
    };
    canvas.ontouchend = ()=>{ isDrawing = false; isMoving = false; };
    // ----------- Selection Tool -------------
    canvas.onclick = e => {
      if (currentTool === TOOL_SELECT && !isPlaying) {
        let pt = getCanvasPos(e);
        let idx = hitTest(pt, strokes[currentFrameIdx]);
        selectedStrokeIdx = idx;
        renderFrame();
      } else if (currentTool === TOOL_SMOOTH && !isPlaying) {
        let pt = getCanvasPos(e);
        let idx = hitTest(pt, strokes[currentFrameIdx]);
        selectedStrokeIdx = idx;
        renderFrame();
      }
    };
    canvas.ondblclick = e => {
      if (currentTool === TOOL_SELECT && selectedStrokeIdx !== null) {
        isMoving = true;
        moveOffset = getCanvasPos(e);
      }
    };
    // ----------- Tools UI -------------
    function setTool(tool) {
      currentTool = tool;
      document.getElementById('draw-tool').classList.toggle('selected', tool===TOOL_DRAW);
      document.getElementById('select-tool').classList.toggle('selected', tool===TOOL_SELECT);
      document.getElementById('smooth-tool').classList.toggle('selected', tool===TOOL_SMOOTH);
      selectedStrokeIdx = null;
      renderFrame();
    }
    document.getElementById('draw-tool').onclick = ()=>setTool(TOOL_DRAW);
    document.getElementById('select-tool').onclick = ()=>setTool(TOOL_SELECT);
    document.getElementById('smooth-tool').onclick = ()=>setTool(TOOL_SMOOTH);
    // Smoothing tool
    document.getElementById('smooth-tool').ondblclick = ()=>{
      if (selectedStrokeIdx !== null) {
        let frameStrokes = strokes[currentFrameIdx];
        frameStrokes[selectedStrokeIdx] = smoothStroke(frameStrokes[selectedStrokeIdx], 24);
        renderFrame();
      }
    };
    // ----------- UI Controls -------------
    colorPicker.oninput = e => brushColor = e.target.value;
    brushSizeInput.oninput = e => brushSize = parseInt(e.target.value);
    document.getElementById('clear-btn').onclick = () => {
      strokes[currentFrameIdx] = blankStrokes();
      selectedStrokeIdx = null;
      renderFrame();
      saveFrame();
    };
    document.getElementById('add-frame-btn').onclick = () => {
      saveFrame();
      strokes.splice(currentFrameIdx+1,0,blankStrokes());
      currentFrameIdx++;
      selectedStrokeIdx = null;
      renderFrame();
      renderFramesPanel();
      updateFrameCounter();
    };
    document.getElementById('dup-frame-btn').onclick = () => {
      saveFrame();
      const dup = JSON.parse(JSON.stringify(strokes[currentFrameIdx]));
      strokes.splice(currentFrameIdx+1,0,dup);
      currentFrameIdx++;
      selectedStrokeIdx = null;
      renderFrame();
      renderFramesPanel();
      updateFrameCounter();
    };
    document.getElementById('del-frame-btn').onclick = () => {
      if (strokes.length===1) return;
      strokes.splice(currentFrameIdx,1);
      currentFrameIdx = Math.max(0,currentFrameIdx-1);
      selectedStrokeIdx = null;
      renderFrame();
      renderFramesPanel();
      updateFrameCounter();
    };
    document.getElementById('prev-frame-btn').onclick = () => {
      saveFrame();
      if (currentFrameIdx>0) currentFrameIdx--;
      selectedStrokeIdx = null;
      renderFrame();
      renderFramesPanel();
      updateFrameCounter();
    };
    document.getElementById('next-frame-btn').onclick = () => {
      saveFrame();
      if (currentFrameIdx<strokes.length-1) currentFrameIdx++;
      selectedStrokeIdx = null;
      renderFrame();
      renderFramesPanel();
      updateFrameCounter();
    };
    // ----------- Animation Playback & Audio -------------
    document.getElementById('play-btn').onclick = () => {
      if (isPlaying) return;
      isPlaying = true;
      document.getElementById('play-btn').disabled = true;
      document.getElementById('stop-btn').disabled = false;
      let idx = 0;
      const fps = Math.max(1, Math.min(60, parseInt(fpsInput.value)));
      const speed = parseFloat(speedInput.value);
      // Audio
      if (audioURL) {
        audioPlayer.currentTime = 0;
        audioPlayer.play();
      }
      playTimer = setInterval(()=>{
        currentFrameIdx = idx;
        renderFrame();
        renderFramesPanel();
        updateFrameCounter();
        idx++;
        if (idx >= strokes.length) {
          idx = 0;
          if (audioURL) audioPlayer.pause();
        }
      }, 1000/(fps*speed));
    };
    document.getElementById('stop-btn').onclick = () => {
      isPlaying = false;
      document.getElementById('play-btn').disabled = false;
      document.getElementById('stop-btn').disabled = true;
      clearInterval(playTimer);
      if (audioURL) audioPlayer.pause();
      renderFrame();
    };
    // ----------- Export / Import -------------
    document.getElementById('export-btn').onclick = () => {
      // Export as JSON: strokes + audio ref
      const data = {
        strokes: strokes,
        audioName: audioName,
        audioURL: audioURL ? audioURL : null
      };
      const blob = new Blob([JSON.stringify(data)],{type:'application/json'});
      const a = document.createElement('a');
      a.href = URL.createObjectURL(blob);
      a.download = 'animation.json';
      a.click();
    };
    document.getElementById('import-btn').onclick = () => {
      document.getElementById('import-file').click();
    };
    document.getElementById('import-file').onchange = e => {
      const file = e.target.files[0];
      if (!file) return;
      const reader = new FileReader();
      reader.onload = evt => {
        try {
          const data = JSON.parse(evt.target.result);
          strokes = data.strokes || [blankStrokes()];
          audioName = data.audioName || '';
          if(data.audioURL) {
            audioURL = data.audioURL;
            audioPlayer.src = audioURL;
            audioNameEl.textContent = audioName;
          } else {
            audioURL = null;
            audioPlayer.src = '';
            audioNameEl.textContent = '';
          }
          currentFrameIdx = 0;
          selectedStrokeIdx = null;
          setTimeout(()=>{renderFrame(); renderFramesPanel(); updateFrameCounter();},200);
        } catch(e) { alert('Import failed!'); }
      };
      reader.readAsText(file);
    };
    // ----------- Audio Upload -------------
    document.getElementById('audio-btn').onclick = () => {
      document.getElementById('audio-upload').click();
    };
    document.getElementById('audio-upload').onchange = e => {
      const file = e.target.files[0];
      if (!file) return;
      const reader = new FileReader();
      reader.onload = evt => {
        audioURL = evt.target.result;
        audioPlayer.src = audioURL;
        audioPlayer.style.display = '';
        audioName = file.name;
        audioNameEl.textContent = file.name;
      };
      reader.readAsDataURL(file);
    };
    // ----------- Utility Functions -------------
    function getCanvasPos(e) {
      const rect = canvas.getBoundingClientRect();
      return {x: (e.clientX - rect.left), y: (e.clientY - rect.top)};
    }
    function getCanvasTouchPos(e) {
      const rect = canvas.getBoundingClientRect();
      const t = e.touches[0];
      return {x: t.clientX - rect.left, y: t.clientY - rect.top};
    }
    // Hit test: find stroke closest to point
    function hitTest(pt, strokesArr) {
      let minDist = 16, found = null;
      for(let i=0;i<strokesArr.length;i++) {
        let stroke = strokesArr[i];
        for(let j=0;j<stroke.length;j++) {
          let d = Math.hypot(pt.x - stroke[j].x, pt.y - stroke[j].y);
          if (d < minDist) { minDist = d; found = i; }
        }
      }
      return found;
    }
    // ----------- Initial Setup -------------
    window.onload = () => {
      initFrames();
      renderFrame();
      renderFramesPanel();
      updateFrameCounter();
    };
  </script>
</body>
</html>
