<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Animation Tool</title>
  <meta name="viewport" content="width=device-width,initial-scale=1.0">
  <style>
    body { font-family: sans-serif; background: #222; color: #eee; margin: 0; padding: 0; }
    .toolbar {
      background: #333; display: flex; gap: 1em; align-items: center; padding: 1em;
      flex-wrap: wrap;
    }
    .toolbar label { margin-right: 0.5em; }
    #canvas-container { display: flex; justify-content: center; align-items: center; padding: 1em; }
    #draw-canvas { border: 2px solid #444; background: #fff; border-radius: 8px; cursor: crosshair; box-shadow: 0 2px 16px #0007; }
    .frames-panel {
      display: flex; gap: 0.5em; padding: 1em; overflow-x: auto; background: #222;
      border-top: 2px solid #333;
    }
    .frame-thumb {
      width: 64px; height: 48px; border: 2px solid #444; border-radius: 4px; cursor: pointer;
      background: #fff; object-fit: contain; box-shadow: 0 1px 4px #0004;
      transition: border .2s;
    }
    .frame-thumb.selected { border: 2px solid #1e90ff; }
    .frame-controls button { margin-right: 0.5em; }
    button, input[type="color"], input[type="number"], input[type="range"] {
      border-radius: 4px; border: 1px solid #444; background: #2a2a2a; color: #eee; padding: .3em .7em; font-size: 1em;
    }
    button:active { background: #444; }
    .fps-speed-container { display: flex; gap: 1em; align-items: center; }
    @media (max-width: 600px) {
      .frames-panel { flex-wrap: wrap; overflow-x: visible; }
      #draw-canvas { width: 100vw !important; height: calc(100vw * 0.75) !important; max-width: 100vw; }
    }
  </style>
</head>
<body>
  <div class="toolbar">
    <label>Color: <input type="color" id="color-picker" value="#1e90ff"></label>
    <label>Brush: <input type="range" id="brush-size" min="1" max="40" value="4"></label>
    <span class="fps-speed-container">
      <label>FPS: <input type="number" id="fps" min="1" max="60" value="12" style="width:3em"></label>
      <label>Speed:
        <select id="speed">
          <option value="0.5">0.5x</option>
          <option value="1" selected>1x</option>
          <option value="1.5">1.5x</option>
          <option value="2">2x</option>
        </select>
      </label>
    </span>
    <button id="play-btn">‚ñ∂Ô∏è Play</button>
    <button id="stop-btn" disabled>‚èπÔ∏è Stop</button>
    <button id="clear-btn">üßπ Clear</button>
    <button id="export-btn">üíæ Export</button>
    <button id="import-btn">üì• Import</button>
    <input type="file" id="import-file" style="display:none">
  </div>
  <div id="canvas-container">
    <canvas id="draw-canvas" width="640" height="480"></canvas>
  </div>
  <div class="frame-controls toolbar">
    <button id="add-frame-btn">‚ûï Add Frame</button>
    <button id="dup-frame-btn">üìã Duplicate</button>
    <button id="del-frame-btn">üóëÔ∏è Delete</button>
    <button id="prev-frame-btn">‚¨ÖÔ∏è Prev</button>
    <button id="next-frame-btn">Next ‚û°Ô∏è</button>
    <span>Frame: <span id="current-frame"></span> / <span id="total-frames"></span></span>
  </div>
  <div class="frames-panel" id="frames-panel"></div>
  <script>
    // State
    let frames = [];
    let currentFrameIdx = 0;
    let isDrawing = false, lastX = 0, lastY = 0;
    let brushColor = '#1e90ff';
    let brushSize = 4;
    let isPlaying = false, playTimer = null;
    const canvas = document.getElementById('draw-canvas');
    const ctx = canvas.getContext('2d');
    const fpsInput = document.getElementById('fps');
    const speedInput = document.getElementById('speed');
    const colorPicker = document.getElementById('color-picker');
    const brushSizeInput = document.getElementById('brush-size');
    const currentFrameElem = document.getElementById('current-frame');
    const totalFramesElem = document.getElementById('total-frames');
    const framesPanel = document.getElementById('frames-panel');
    // Helper: create a blank frame
    function blankFrame() {
      const f = document.createElement('canvas');
      f.width = canvas.width; f.height = canvas.height;
      f.getContext('2d').fillStyle = '#fff';
      f.getContext('2d').fillRect(0,0,canvas.width,canvas.height);
      return f;
    }
    // Initialize with one frame
    function initFrames() {
      frames = [blankFrame()];
      currentFrameIdx = 0;
      renderFrame();
      renderFramesPanel();
      updateFrameCounter();
    }
    // Draw the current frame to canvas
    function renderFrame() {
      ctx.clearRect(0,0,canvas.width,canvas.height);
      ctx.drawImage(frames[currentFrameIdx],0,0);
    }
    // Save the current canvas to current frame
    function saveFrame() {
      frames[currentFrameIdx].getContext('2d').drawImage(canvas,0,0);
      renderFramesPanel();
    }
    // Render all frame thumbnails
    function renderFramesPanel() {
      framesPanel.innerHTML = '';
      frames.forEach((f,i)=>{
        const thumb = document.createElement('canvas');
        thumb.width = 64; thumb.height = 48;
        thumb.className = 'frame-thumb' + (i===currentFrameIdx ? ' selected':'');
        thumb.title = `Frame ${i+1}`;
        thumb.getContext('2d').drawImage(f,0,0,64,48);
        thumb.onclick = ()=>{ saveFrame(); currentFrameIdx=i; renderFrame(); renderFramesPanel(); updateFrameCounter(); };
        framesPanel.appendChild(thumb);
      });
    }
    function updateFrameCounter() {
      currentFrameElem.textContent = currentFrameIdx+1;
      totalFramesElem.textContent = frames.length;
    }
    // Drawing logic
    canvas.addEventListener('mousedown', e => {
      if (isPlaying) return;
      isDrawing = true;
      [lastX, lastY] = [e.offsetX, e.offsetY];
    });
    canvas.addEventListener('mousemove', e => {
      if (!isDrawing || isPlaying) return;
      ctx.strokeStyle = brushColor;
      ctx.lineWidth = brushSize;
      ctx.lineCap = 'round';
      ctx.beginPath();
      ctx.moveTo(lastX, lastY);
      ctx.lineTo(e.offsetX, e.offsetY);
      ctx.stroke();
      [lastX, lastY] = [e.offsetX, e.offsetY];
    });
    canvas.addEventListener('mouseup', ()=>{ isDrawing=false; saveFrame(); });
    canvas.addEventListener('mouseleave', ()=>{ isDrawing=false; });
    // Touch events (mobile)
    canvas.addEventListener('touchstart', e => {
      if (isPlaying) return;
      e.preventDefault();
      isDrawing = true;
      const rect = canvas.getBoundingClientRect();
      const touch = e.touches[0];
      [lastX, lastY] = [touch.clientX - rect.left, touch.clientY - rect.top];
    });
    canvas.addEventListener('touchmove', e => {
      if (!isDrawing || isPlaying) return;
      e.preventDefault();
      const rect = canvas.getBoundingClientRect();
      const touch = e.touches[0];
      const x = touch.clientX - rect.left;
      const y = touch.clientY - rect.top;
      ctx.strokeStyle = brushColor;
      ctx.lineWidth = brushSize;
      ctx.lineCap = 'round';
      ctx.beginPath();
      ctx.moveTo(lastX, lastY);
      ctx.lineTo(x, y);
      ctx.stroke();
      [lastX, lastY] = [x, y];
    });
    canvas.addEventListener('touchend', ()=>{ isDrawing=false; saveFrame(); });
    // Controls
    colorPicker.oninput = e => brushColor = e.target.value;
    brushSizeInput.oninput = e => brushSize = parseInt(e.target.value);
    document.getElementById('clear-btn').onclick = () => {
      ctx.fillStyle = '#fff';
      ctx.fillRect(0,0,canvas.width,canvas.height);
      saveFrame();
    };
    document.getElementById('add-frame-btn').onclick = () => {
      saveFrame();
      const newF = blankFrame();
      frames.splice(currentFrameIdx+1,0,newF);
      currentFrameIdx++;
      renderFrame();
      renderFramesPanel();
      updateFrameCounter();
    };
    document.getElementById('dup-frame-btn').onclick = () => {
      saveFrame();
      const dup = blankFrame();
      dup.getContext('2d').drawImage(frames[currentFrameIdx],0,0);
      frames.splice(currentFrameIdx+1,0,dup);
      currentFrameIdx++;
      renderFrame();
      renderFramesPanel();
      updateFrameCounter();
    };
    document.getElementById('del-frame-btn').onclick = () => {
      if (frames.length===1) return;
      frames.splice(currentFrameIdx,1);
      currentFrameIdx = Math.max(0,currentFrameIdx-1);
      renderFrame();
      renderFramesPanel();
      updateFrameCounter();
    };
    document.getElementById('prev-frame-btn').onclick = () => {
      saveFrame();
      if (currentFrameIdx>0) currentFrameIdx--;
      renderFrame();
      renderFramesPanel();
      updateFrameCounter();
    };
    document.getElementById('next-frame-btn').onclick = () => {
      saveFrame();
      if (currentFrameIdx<frames.length-1) currentFrameIdx++;
      renderFrame();
      renderFramesPanel();
      updateFrameCounter();
    };
    // Animation playback
    document.getElementById('play-btn').onclick = () => {
      saveFrame();
      if (isPlaying) return;
      isPlaying = true;
      document.getElementById('play-btn').disabled = true;
      document.getElementById('stop-btn').disabled = false;
      let idx = 0;
      const fps = Math.max(1, Math.min(60, parseInt(fpsInput.value)));
      const speed = parseFloat(speedInput.value);
      playTimer = setInterval(()=>{
        ctx.clearRect(0,0,canvas.width,canvas.height);
        ctx.drawImage(frames[idx],0,0);
        idx++;
        if (idx>=frames.length) idx=0;
      }, 1000/(fps*speed));
    };
    document.getElementById('stop-btn').onclick = () => {
      isPlaying = false;
      document.getElementById('play-btn').disabled = false;
      document.getElementById('stop-btn').disabled = true;
      clearInterval(playTimer);
      renderFrame();
    };
    // Export/Import
    document.getElementById('export-btn').onclick = () => {
      saveFrame();
      // Export as JSON with base64 PNGs
      const json = JSON.stringify(frames.map(f => f.toDataURL()));
      const blob = new Blob([json],{type:'application/json'});
      const a = document.createElement('a');
      a.href = URL.createObjectURL(blob);
      a.download = 'animation.json';
      a.click();
    };
    document.getElementById('import-btn').onclick = () => {
      document.getElementById('import-file').click();
    };
    document.getElementById('import-file').onchange = e => {
      const file = e.target.files[0];
      if (!file) return;
      const reader = new FileReader();
      reader.onload = evt => {
        try {
          const arr = JSON.parse(evt.target.result);
          frames = arr.map(url=>{
            const img = new window.Image();
            const c = blankFrame();
            img.onload = ()=>{ c.getContext('2d').drawImage(img,0,0); renderFrame(); renderFramesPanel(); updateFrameCounter();};
            img.src = url;
            return c;
          });
          currentFrameIdx = 0;
          setTimeout(()=>{renderFrame(); renderFramesPanel(); updateFrameCounter();},500);
        } catch(e) { alert('Import failed!'); }
      };
      reader.readAsText(file);
    };
    // Initial setup
    window.onload = () => {
      initFrames();
      renderFrame();
      renderFramesPanel();
      updateFrameCounter();
    };
  </script>
</body>
</html>
